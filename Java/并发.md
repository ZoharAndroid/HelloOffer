  
<h1>并发</h1>
<!-- TOC -->

- [1. 什么是进程和线程？](#1-什么是进程和线程)
- [2. 为什么程序计数器、虚拟机栈和本地方法栈是私有的?](#2-为什么程序计数器虚拟机栈和本地方法栈是私有的)
    - [2.1. 程序计数器](#21-程序计数器)
    - [2.2. 虚拟机栈](#22-虚拟机栈)
    - [2.3. 本地方法栈](#23-本地方法栈)
- [3. 并发与并行的区别？](#3-并发与并行的区别)
- [4. 线程的生命周期和状态](#4-线程的生命周期和状态)

<!-- /TOC -->
  
# 1. 什么是进程和线程？
  
* **进程**：进程是系统运行程序的最小单位，系统运行一个程序就相当于创建一个进程。
* **线程**：线程与进程相似，但是线程是比进程更小的执行单位。一个进程可以产生多个线程。线程可以共享进程的堆和方法区资源，每个线程都拥有自己的**程序计数器、虚拟机栈和本地方法栈**，所以系统产生一个线程或者线程之间切换时，负担比进程要小。

# 2. 为什么程序计数器、虚拟机栈和本地方法栈是私有的?

## 2.1. 程序计数器

程序计数器主要的两个作用：

1. 字节码解释器通过读取程序计数器来读取下一条将要执行的指令，从而实现代码的流程控制，如：顺序执行、选择、循环、线程切换等；
2. 在多线程的情况下，程序计数器可以记录当前线程执行的位置，从而当前线程被切换回来的时候能够知道该线程上次运行到哪里了。

所以程序计数器私有主要是**为了线程切换后能够恢复到正确的位置继续执行**。

## 2.2. 虚拟机栈

每个java方法在执行的同时，会创建一个栈帧用于存储局部变量、操作数栈、常量引用池等信息。从方法调用直到执行完成，就对应一个栈帧从java虚拟机栈中入栈出栈的过程。

## 2.3. 本地方法栈

本地方法栈和虚拟机栈发挥的作用非常类似，只不过本地方法栈是为native方法服务的，而虚拟机栈是为字节码服务的。

所以，**为了保证线程的局部变量不被别的线程访问，虚拟机栈和本地方法栈是私有的**。

# 3. 并发与并行的区别？

* **并发**：同一时间段，多个任务都在执行（单位时间内不一定同时执行）。
* **并行**：单位时间内，多个任务同时执行。

# 4. 线程的生命周期和状态

Java线程的生命周期只可能是下面6中状态中的一个状态：

状态名称|说明
|:-:|:-:|
**NEW**|**初始状态**，线程被构建，但是还没有调用start()方法
**RUNNABLE**|**运行状态**，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”
**BLOCKED**|**阻塞状态**，表示线程阻塞于锁
**WAITTING**|**等待状态**，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程
**TIME_WAITING**|**超时等待状态**，该状态不同于WAITING，它是可以在指定的时间自行返回的
**TERMINATED**|**终止状态**，表示当前线程已经执行完毕

现成的生命周期并不是固定的处于某一个状态而是随着代码的执行在不同状态之间切换。

![](https://github.com/ZoharAndroid/MarkdownImages/blob/master/2019-07/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png?raw=true)

由上图可以看出：线程创建之后它将处于**NEW**（新建）状态，调用 `start()`方法后开始运行，线程这时候处于**READY**（可运行）状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于**RUNNING**（运行）状态。

当线程执行`wait()`方法之后，线程进入 **WAITING**（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 **TIME_WAITING**(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过`sleep（long millis）`方法或 `wait（long millis）`方法可以将 Java 线程置于**TIMED WAITING** 状态。当超时时间到达后, Java 线程将会返回到**RUNNABLE** 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到**BLOCKED**（阻塞） 状态。线程在执行**Runnable** 的`run()`方法之后将会进入到**TERMINATED**（终止） 状态。
