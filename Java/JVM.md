# Java虚拟机
  
  
* [Java虚拟机](#java虚拟机 )
* [1. Java内存区域与内存溢出异常](#1-java内存区域与内存溢出异常 )
	* [1.1 运行时数据区域](#11-运行时数据区域 )
		* [1.1.1 程序计数器](#111-程序计数器 )
		* [1.1.2 虚拟机栈](#112-虚拟机栈 )
		* [1.1.3 本地方法栈](#113-本地方法栈 )
		* [1.1.4 Java堆](#114-java堆 )
		* [1.1.5 方法区](#115-方法区 )
		* [1.1.6 运行时常量池](#116-运行时常量池 )
		* [1.1.7 直接内存](#117-直接内存 )
  
# 1. Java内存区域与内存溢出异常
  
  
## 1.1 运行时数据区域
  
  
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机**进程**的启动而存在，有些区域则依赖**用户线程**的启动和结束而建立和销毁。JDK1.8之前与之后的运行时数据区域略有不同。
  
**JDK1.8之前:**
  
![](https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67 )
  
**JDK1.8之后:**
  
![](https://camo.githubusercontent.com/0bcc6c01a919b175827f0d5540aeec115df6c001/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d334a617661e8bf90e8a18ce697b6e695b0e68daee58cbae59f9f4a444b312e382e706e67 )
  
**线程共享**：
  
* 堆
* 方法区（包括运行时常量池）
* 直接内存（这里是非运行时数据区的一部分）
  
**线程私有**：
  
* 虚拟机栈
* 程序计数器
* 本地方法栈
  
### 1.1.1 程序计数器
  
程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。**字节码解释器就是通过程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个程序技术器来完成。**
  
为了线程切换后能恢复到正确的执行位置，**每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储**，称这类内存区域为“**线程私有**”内存。程序计数器是线程私有的，生命周期与线程相同。
  
如果线程正在执行一个Java方法，程序计数器记录的就是正在执行的**虚拟机字节码指令的地址**。如果线程正在执行native方法，程序计数器的值为空。
  
**程序计数器是内存区域唯一一个在Java虚拟机规范中没有规定任何的OutOfMemoryError的情况。**
  
> 小结：
> 从上面的介绍来看，可以得知程序计数器的主要功能：
> 
>  1. 字节码解释器通过程序计数器的值来依次读取指令。
>  2. 在多线程的情况下，程序计数器可以保存当前线程执行的位置，线程切换返回之后，不受影响，继续执行。
> 
  
### 1.1.2 虚拟机栈
  
  
**虚拟机栈也是线程私有的**，生命周期和线程相同。
  
虚拟机栈描述的是Java方法执行的内存模型：
**每个方法在执行的同时都会创建一个栈帧**用于存储局部变量表、操作数栈、方法出口等信息。**每一个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。**
  
经常有人把Java内存区分为**堆内存（Heap）**和**栈内存（Stack）**，**栈内存就是指虚拟机栈或者说是虚拟机栈中的局部变量表**。
  
**局部变量表存放了编译器期间可知的各种基本数据类型**（boolean、short、int、long、float、double、byte、char）、**对象引用**（reference类，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和**returnAddress类型**（指向了一条字节码指令的地址）。
  
**局部变量表所需要的内存空间在编译期间就已经完成分配了**，当进入一个方法是，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间是不会改变局部变量表的大小。
  
该区域规定了两种异常状况：
  
* **StackOverflowError**：线程请求的栈深度大于虚拟机所允许的深度
* **OutOfMemoryError**：如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存
  
**问题：方法如何调用？**
  
Java栈类似于数据结构的栈结构，Java栈中主要保存的是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个方法调用结束后，栈帧又会被弹出。
  
Java两种返回方式：
  
1. return返回
2. 抛出异常。
  
不管哪种方式，都会弹出栈帧。
  
### 1.1.3 本地方法栈
  
  
与虚拟机栈发挥的作用相似，区别是：**虚拟机栈是为虚拟机执行Java方法(也就是字节码)服务的，本地方法栈则是为虚拟机使用到的native方法服务的**。
  
本地方法栈也会创建一个栈帧，用于存储本地方法的局部变量表、操作数栈、动态链接、出口等信息。
  
HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一，与虚拟机栈一样，也会出现**StackOverflowError**和**OutOfMemoryError**异常。
  
### 1.1.4 Java堆
  
  
Java堆（Java Heap）是Java虚拟机所管理的内存最大一块，**Java堆是被所有线程共享的一块内存区域，虚拟机启动时创建Java堆。次内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在Java堆进行内存分配。**Java虚拟机规范中描述：**所有的对象实例以及数组都要在堆上分配**。
  
**Java堆是垃圾收集器管理的主要区域**，因此也被称为“GC堆（Garbage Collected Heap）”。
  
**从内存回收的角度来看**，现在收集器采用的分代收集算法，所以Java堆可细分为：**新生代和老年代；再细分一点有Eden空间、From Survivor空间、To Survivor空间**。
  
**从内存分配的角度来看**，线程共享的Java堆可以划分出多个线程私有的分配缓冲区（Thead Local Allocation Buffer，TLAB），不过无论怎么划分，都与存放内从无关，无论哪个区域，**存储的都是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存**。
  
Java堆可以处于物理上不连续的内存空间中，只要逻辑连续即可。堆大小可以固定也可以扩展，扩展通过`-Xmx`和`-Xms`控。
  
如果堆中没有内存完成实例分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常。
  
### 1.1.5 方法区
  
  
方法区（Method Area）与java堆一样，是**各个线程共享的内存区域，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器变异后的代码等数据**。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是方法去有个别名叫做Non-Heap（非堆），目的是与Java堆进行区分。
  
在HotSpot虚拟机，很多人把方法区成为“永久代”，仅仅是因为HotSpot虚拟机设计团队选择把GC分代收集器扩展至方法区，或者使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存了，免去了还单独为方法区编写内存管理的代码，实际上方法区和永久代并不等价。
  
> **永久代和方法区的区别**？
> **方法区**是Java虚拟机规范中的一个慨念和作用，但是并没有规定如何具体的去实现。不同的JVM虚拟机肯定实现方式是不一样的。而**永久代**是HotSpot虚拟机团队是对方法区一种实现方式。
  
在JDK1.7中的HotSpot中，已经把原本放在永久代的字符串常量池移出。永久代也逐步改为采用native memory来实现方法区。
  
当方法区无法满足内存分配需求的时候，会跑出OutOfMemoryError异常。
  
### 1.1.6 运行时常量池
  
**运行时常量池（Runtime Constant Pool）是方法区的一部分**。Class文件中除了有类的版本信息、子段、方法、接口等信息外，还有一项信息就是常量池，用于存放编译期间生成的各种**字面量**和**符号引用**。

既然运行时常量池是方法去的一部分，自然受到方法区内存的限制，当常量池无法再申请内存时会抛出**OutOfMemoryError**异常。

**JDK1.7之后已经将运行时常量池移出到Java堆中**。

![](https://github.com/ZoharAndroid/MarkdownImages/blob/master/2019-6-7/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.jpg?raw=true)
  
### 1.1.7 直接内存

**直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域**。但是这部分内存也被频繁的使用，而且可可能导致OutOfMemoryError异常出现。
  
在JDK1.4中加入的**NIO**（New Input/Output）类，**引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式**。它可以**使用native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作**，这样能在一些场景中显著提高性能，因为**避免了在Java堆和native堆中来回复制数据**。

> 这句话的意思就是：通过Java堆的DirectByteBuffer对象来操作native函数分配的堆外内存。


## 1.2 HotSpot虚拟机对象探秘

通过上面的介绍大致知道了虚拟机内存的概况，知道了内存中放了些什么，下面继续学习HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

参考：
  
* 周志明. 深入理解Java虚拟机(第2版)
* github. JavaGuide
  