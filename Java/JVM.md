# Java虚拟机

[toc]

# 1. Java内存区域与内存溢出异常

## 1.1 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机**进程**的启动而存在，有些区域则依赖**用户线程**的启动和结束而建立和销毁。JDK1.8之前与之后的运行时数据区域略有不同。

**JDK1.8之前:**

![](https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67)

**JDK1.8之后:**

![](https://camo.githubusercontent.com/0bcc6c01a919b175827f0d5540aeec115df6c001/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d334a617661e8bf90e8a18ce697b6e695b0e68daee58cbae59f9f4a444b312e382e706e67)

**线程共享**：

* 堆
* 方法区（包括运行时常量池）
* 直接内存（这里是非运行时数据区的一部分）

**线程私有**：

* 虚拟机栈
* 程序计数器
* 本地方法栈

### 1.1.1 程序计数器

程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。**字节码解释器就是通过程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个程序技术器来完成。**

为了线程切换后能恢复到正确的执行位置，**每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储**，称这类内存区域为“**线程私有**”内存。程序计数器是线程私有的，声明周期与线程相同。

如果线程正在执行一个Java方法，程序计数器记录的就是正在执行的**虚拟机字节码指令的地址**。如果线程正在执行native方法，成熟计数器的值为空。

**程序计数器是内存区域唯一一个在Java虚拟机规范中没有规定任何的OutOfMemoryError的情况。**

> 从上面的介绍来看，可以得知程序计数器的主要功能：
> 
>  1. 字节码解释器通过程序计数器的值来依次读取指令。
>  2. 在多线程的情况下，程序计数器可以保存当前线程执行的位置，线程切换之后，不受影响，继续执行。
> 

### 1.1.2 虚拟机栈

**虚拟机栈也是线程私有的**，生命周期和线程相同。

虚拟机栈描述的是Java方法执行的内存模型：
**每个方法在执行的同时都会创建一个栈帧**用于存储局部变量表、操作数栈、方法出口等信息。**每一个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。**

经常有人把Java内存区分为**堆内存（Heap）**和**栈内存（Stack）**，**栈内存就是指虚拟机栈或者说是虚拟机栈中的局部变量表**。

**局部变量表存放了编译器期间可知的各种基本数据类型**（boolean、short、int、long、float、double、byte、char）、**对象引用**（reference类，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和**returnAddress类型**（指向了一条字节码指令的地址）。

**局部变量表所需要的内存空间在编译期间就已经完成分配了**，当进入一个方法是，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间是不会改变局部变量表的大小。

该区域规定了两种异常状况：

* **StackOverflowError**：线程请求的栈深度大于虚拟机所允许的深度
* **OutOfMemoryError**：如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存

**问题：方法如何调用？**
Java栈类似于数据结构的栈结构，Java栈中主要保存的是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个方法调用结束后，栈帧又会被弹出。

Java两种返回方式：

1. return返回
2. 抛出异常。

不管哪种方式，都会弹出栈帧。

### 1.1.3 本地方法栈

与虚拟机栈发挥的作用相似，区别是：**虚拟机栈是为虚拟机执行Java方法(也就是字节码)服务的，本地方法栈则是为虚拟机使用到的native方法服务的**。

本地方法栈也会创建一个栈帧，用于存储本地方法的局部变量表、操作数栈、动态链接、出口等信息。

也会出现**StackOverflowError**和**OutOfMemoryError**异常。

参考：

* 周志明. 深入理解Java虚拟机(第2版)
* github. JavaGuide