# Java虚拟机

[toc]

# 1. Java内存区域与内存溢出异常
  
## 1.1 运行时数据区域
  
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机**进程**的启动而存在，有些区域则依赖**用户线程**的启动和结束而建立和销毁。JDK1.8之前与之后的运行时数据区域略有不同。
  
**JDK1.8之前:**
  
![](https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67 )
  
**JDK1.8之后:**
  
![](https://camo.githubusercontent.com/0bcc6c01a919b175827f0d5540aeec115df6c001/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d334a617661e8bf90e8a18ce697b6e695b0e68daee58cbae59f9f4a444b312e382e706e67 )
  
**线程共享**：
  
* 堆
* 方法区（包括运行时常量池）
* 直接内存（这里是非运行时数据区的一部分）
  
**线程私有**：
  
* 虚拟机栈
* 程序计数器
* 本地方法栈
  
### 1.1.1 程序计数器
  
程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。**字节码解释器就是通过程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个程序技术器来完成。**
  
为了线程切换后能恢复到正确的执行位置，**每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储**，称这类内存区域为“**线程私有**”内存。程序计数器是线程私有的，生命周期与线程相同。
  
如果线程正在执行一个Java方法，程序计数器记录的就是正在执行的**虚拟机字节码指令的地址**。如果线程正在执行native方法，程序计数器的值为空。
  
**程序计数器是内存区域唯一一个在Java虚拟机规范中没有规定任何的OutOfMemoryError的情况。**
  
> 小结：
> 从上面的介绍来看，可以得知程序计数器的主要功能：
> 
>  1. 字节码解释器通过程序计数器的值来依次读取指令。
>  2. 在多线程的情况下，程序计数器可以保存当前线程执行的位置，线程切换返回之后，不受影响，继续执行。 
  
### 1.1.2 虚拟机栈
  
**虚拟机栈也是线程私有的**，生命周期和线程相同。
  
虚拟机栈描述的是Java方法执行的内存模型：
**每个方法在执行的同时都会创建一个栈帧**用于存储局部变量表、操作数栈、方法出口等信息。**每一个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。**
  
经常有人把Java内存区分为**堆内存（Heap）**和**栈内存（Stack）**，**栈内存就是指虚拟机栈或者说是虚拟机栈中的局部变量表**。
  
**局部变量表存放了编译器期间可知的各种基本数据类型**（boolean、short、int、long、float、double、byte、char）、**对象引用**（reference类，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和**returnAddress类型**（指向了一条字节码指令的地址）。
  
**局部变量表所需要的内存空间在编译期间就已经完成分配了**，当进入一个方法是，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间是不会改变局部变量表的大小。
  
该区域规定了两种异常状况：
  
* **StackOverflowError**：线程请求的栈深度大于虚拟机所允许的深度
* **OutOfMemoryError**：如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存
  
**问题：方法如何调用？**
  
Java栈类似于数据结构的栈结构，Java栈中主要保存的是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个方法调用结束后，栈帧又会被弹出。
  
Java两种返回方式：
  
1. return返回
2. 抛出异常。
  
不管哪种方式，都会弹出栈帧。
  
### 1.1.3 本地方法栈
  
  
与虚拟机栈发挥的作用相似，区别是：**虚拟机栈是为虚拟机执行Java方法(也就是字节码)服务的，本地方法栈则是为虚拟机使用到的native方法服务的**。
  
本地方法栈也会创建一个栈帧，用于存储本地方法的局部变量表、操作数栈、动态链接、出口等信息。
  
HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一，与虚拟机栈一样，也会出现**StackOverflowError**和**OutOfMemoryError**异常。
  
### 1.1.4 Java堆
  
  
Java堆（Java Heap）是Java虚拟机所管理的内存最大一块，**Java堆是被所有线程共享的一块内存区域，虚拟机启动时创建Java堆。次内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在Java堆进行内存分配。**Java虚拟机规范中描述：**所有的对象实例以及数组都要在堆上分配**。
  
**Java堆是垃圾收集器管理的主要区域**，因此也被称为“GC堆（Garbage Collected Heap）”。
  
**从内存回收的角度来看**，现在收集器采用的分代收集算法，所以Java堆可细分为：**新生代和老年代；再细分一点有Eden空间、From Survivor空间、To Survivor空间**。
  
**从内存分配的角度来看**，线程共享的Java堆可以划分出多个线程私有的分配缓冲区（Thead Local Allocation Buffer，TLAB），不过无论怎么划分，都与存放内从无关，无论哪个区域，**存储的都是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存**。
  
Java堆可以处于物理上不连续的内存空间中，只要逻辑连续即可。堆大小可以固定也可以扩展，扩展通过`-Xmx`和`-Xms`控。
  
如果堆中没有内存完成实例分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常。
  
### 1.1.5 方法区
  
  
方法区（Method Area）与java堆一样，是**各个线程共享的内存区域，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器变异后的代码等数据**。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是方法去有个别名叫做Non-Heap（非堆），目的是与Java堆进行区分。
  
在HotSpot虚拟机，很多人把方法区成为“永久代”，仅仅是因为HotSpot虚拟机设计团队选择把GC分代收集器扩展至方法区，或者使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存了，免去了还单独为方法区编写内存管理的代码，实际上方法区和永久代并不等价。
  
> **永久代和方法区的区别**？
> **方法区**是Java虚拟机规范中的一个慨念和作用，但是并没有规定如何具体的去实现。不同的JVM虚拟机肯定实现方式是不一样的。而**永久代**是HotSpot虚拟机团队是对方法区一种实现方式。
  
在JDK1.7中的HotSpot中，已经把原本放在永久代的字符串常量池移出。永久代也逐步改为采用native memory来实现方法区。
  
当方法区无法满足内存分配需求的时候，会跑出OutOfMemoryError异常。
  
### 1.1.6 运行时常量池
  
**运行时常量池（Runtime Constant Pool）是方法区的一部分**。Class文件中除了有类的版本信息、子段、方法、接口等信息外，还有一项信息就是常量池，用于存放编译期间生成的各种**字面量**和**符号引用**。

既然运行时常量池是方法去的一部分，自然受到方法区内存的限制，当常量池无法再申请内存时会抛出**OutOfMemoryError**异常。

**JDK1.7之后已经将运行时常量池移出到Java堆中**。

![](https://github.com/ZoharAndroid/MarkdownImages/blob/master/2019-6-7/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.jpg?raw=true)
  
### 1.1.7 直接内存

**直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域**。但是这部分内存也被频繁的使用，而且可可能导致OutOfMemoryError异常出现。
  
在JDK1.4中加入的**NIO**（New Input/Output）类，**引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式**。它可以**使用native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作**，这样能在一些场景中显著提高性能，因为**避免了在Java堆和native堆中来回复制数据**。

> 这句话的意思就是：通过Java堆的DirectByteBuffer对象来操作native函数分配的堆外内存。

## 1.2 HotSpot虚拟机对象探秘

通过上面的介绍大致知道了虚拟机内存的概况，知道了内存中放了些什么，下面继续学习HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

### 1.2.1 对象的创建

![](https://github.com/ZoharAndroid/MarkdownImages/blob/master/2019-6-7/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B.jpg?raw=true)

**第一步：类加载检查**

虚拟机遇到一条new指令时，首先会检查这个指令的参数是否能在**常量池**中定位到一个类的**符号引用**（方法区中的运行时常量池中的符号引用），并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

**第二步：内存分配**

在类加载检查通过后，接下来虚拟机将会为新生对象**分配内存**。**对象所需内存的大小在类加载完成后便可以完全确定**，为对象分配内存空间的任务等同于把一块确定大小的内存从Java堆中划分出来。内存分配方式有两种：“**指针碰撞**”和“**空闲列表**”。具体采用哪种分配方式是由**Java堆是否规整决定的，而Java堆是否规整又是由GC收集器是否带有压缩整理功能决定的**。

**两种分配方式的区别**：
![](https://github.com/ZoharAndroid/MarkdownImages/blob/master/2019-6-8/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png?raw=true)

还有一个问题需要考虑的是：对象创建在虚拟机是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是**线程安全**的，所以还需要考虑线程安全的问题，解决方法有两种方案：
* **CAS+失败重试**方式：CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突去完成某项操作，如果遇到冲突失败，则重试，直到成功。**虚拟机采用CAS配上失败重试的方式保证更新操作的原子性**。
* **TLAB**：每个线程预先分配一小块内存，这块区域也就称为本地线程分配缓冲（TLAB)，**哪个线程要分配内存就在哪个线程的TLAB上进行分配。只有TLAB用完并分配新的TLAB时，才需要采用同步锁定方式**。

**第三步：内存初始化为零值**：

内存分配完成后，虚拟机要将分配到的内存空间都初始化为零值（不包括对象头）。**这一步操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用**，程序能访问到这些字段的数据类型所对应的零值。

**第四步：设置对象头**：

**虚拟机要对对象头进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。**这些信息都存放在对象的对象头之中**。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头都有不同的设置方式。

**第五步：执行`<init>`方法**：

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>`方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行`<init>`方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 1.2.2 对象的内存分配

HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：**对象头、实例数据和对齐填充**。


* **对象头**：对象头包括两部分信息，**第一部分用于存储对象自身的运行时数据**，如哈希吗、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等。**第二部分是类型指针，即对象指向它的类元数据的指针**，虚拟机通过这个指针来确定这个对象是哪个类的实例。

* **实例数据**：**是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容**。

* **对齐填充**：不是必然存在的，也没有什么特别的含义，仅仅**起占位作用**。 因为 Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 1.2.3 对象的访问定位

建立对象是为了适用对象，**Java程序需要通过栈上的reference数据来操作堆上的具体对象**（reference在虚拟机栈上有提到，具体向上查看）。Java虚拟机规范只说reference类型是一个指向对象的引用，并没有定义这个reference应该通过何从方式去定位、访问堆中对象的具体位置，具体实现取决于虚拟机的具体实现。目前主流的访问方式有**使用句柄**和**直接指针**两种。

* **使用句柄方式**：

Java堆中划分一块内存用作句柄池，reference中存储的就是对象的句柄地址，而句柄地址包含了对象的实例数据和类型数据各自的地址信息。
![](https://github.com/ZoharAndroid/MarkdownImages/blob/master/2019-6-8/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png?raw=true)

* **直接指针**：

reference存储的直接就是对象地址，此时在Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息。
![](https://github.com/ZoharAndroid/MarkdownImages/blob/master/2019-6-8/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png?raw=true)

这两种对象访问方式各有优势。使用**句柄来访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改**。使用**直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销**。

参考：
  
* 周志明. 深入理解Java虚拟机(第2版)
* github. JavaGuide
  